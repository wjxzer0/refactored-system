#include "level_set_method.h"Clevel_set_method::Clevel_set_method(){};Clevel_set_method::~Clevel_set_method(){};Clevel_set_method::Clevel_set_method(double left, double right, double bottom,                                     double top, int xNum, int yNum,                                     double time, double time_step,                                     CMatrix<CVariable> &Conserved,                                     CMatrix<double> &distance_phi) {  m_left = left;  m_right = right;  m_top = top;  m_bottom = bottom;  m_xNum = xNum;  m_yNum = yNum;  m_xH = (right - left) / xNum;  m_yH = (top - bottom) / yNum;  m_Time = time;  m_time_step = time_step;  xEnd = m_xNum + xBegin;  yEnd = m_yNum + yBegin;  xTotal = xBegin + xEnd;  yTotal = yBegin + yEnd;  Grid.Resize(xTotal, yTotal);  ini_x_velocity.Resize(xTotal, yTotal);  ini_y_velocity.Resize(xTotal, yTotal);  velocity.Resize(xTotal, yTotal);  phi.Resize(xTotal, yTotal);  phi_temp.Resize(xTotal, yTotal);  ini_phi.Resize(xTotal, yTotal);  X_partial_phi.Resize(xTotal, yTotal);  Y_partial_phi.Resize(xTotal, yTotal);  Grid(xBegin, yBegin).x = m_left + 0.5 * m_xH;  Grid(xBegin, yBegin).y = m_bottom + 0.5 * m_yH;  //划分网格  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      Grid(i, j).x = Grid(xBegin, yBegin).x + (i - xBegin) * m_xH;      Grid(i, j).y = Grid(xBegin, yBegin).y + (j - yBegin) * m_yH;    }  }  //赋值速度场  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      ini_x_velocity(i, j) = Conserved(i, j).u2 / Conserved(i, j).u1;      ini_y_velocity(i, j) = Conserved(i, j).u3 / Conserved(i, j).u1;      ini_phi(i, j) = distance_phi(i, j);    }  }}void Clevel_set_method::Initial() {  //零等值线及物质移动速度初始化  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      //初始零等值线      // function 1椭圆      // phi(i,j) = 0.25*(pow( Grid(i, j).x, 2)) + pow( Grid(i, j).y, 2) - 0.25;      // function 2方形      // phi(i,j) = 16.0*pow( Grid(i, j).x, 4)-4.0*pow( Grid(i, j).x, 2)      // + 16.0*pow( Grid(i, j).y, 4) - 4.0*pow( Grid(i, j).y, 2); function 3圆      // phi(i, j) = pow((pow(Grid(i, j).x, 2) + pow(Grid(i, j).y, 2)), 2.0)      // - 1.0; function 4正方形      //    phi(i,j)=max(fabs(i*m_xH-1.5),fabs(j*m_yH-1.5))-1.0;      phi(i, j) = ini_phi(i, j);      //    if (phi(i,j)>0)phi(i,j)=1.0;      //    else phi(i,j)=-1.0;      //物质界面移动速度值      //常数速度      velocity(i, j).x = ini_x_velocity(i, j);      velocity(i, j).y = ini_y_velocity(i, j);      //非常数速度      // velocity(i,j).x=-pai*(j*m_yH-0.5);      // velocity(i,j).y=pai*(i*m_xH-0.5);    }  }}void Clevel_set_method::level_set_SetBoundary() {  // left  for (int j = yBegin; j != yEnd; j++) {    phi(3, j) = phi(4, j) + phi(4, j) /                                sqrt(phi(4, j) * phi(4, j) + m_xH * m_xH) *                                fabs(phi(4, j) - phi(5, j));    phi(2, j) = phi(3, j) + phi(3, j) /                                sqrt(phi(3, j) * phi(3, j) + m_xH * m_xH) *                                fabs(phi(3, j) - phi(4, j));    phi(1, j) = phi(2, j) + phi(2, j) /                                sqrt(phi(2, j) * phi(2, j) + m_xH * m_xH) *                                fabs(phi(2, j) - phi(3, j));    phi(0, j) = phi(1, j) + phi(1, j) /                                sqrt(phi(1, j) * phi(1, j) + m_xH * m_xH) *                                fabs(phi(1, j) - phi(2, j));  }  // right  for (int j = yBegin; j != yEnd; j++) {    phi(xEnd, j) = phi(xEnd - 1, j) +                   phi(xEnd - 1, j) /                       sqrt(phi(xEnd - 1, j) * phi(xEnd - 1, j) + m_xH * m_xH) *                       fabs(phi(xEnd - 1, j) - phi(xEnd - 2, j));    phi(xEnd + 1, j) =        phi(xEnd, j) + phi(xEnd, j) /                           sqrt(phi(xEnd, j) * phi(xEnd, j) + m_xH * m_xH) *                           fabs(phi(xEnd, j) - phi(xEnd - 1, j));    phi(xEnd + 2, j) =        phi(xEnd + 1, j) +        phi(xEnd + 1, j) /            sqrt(phi(xEnd + 1, j) * phi(xEnd + 1, j) + m_xH * m_xH) *            fabs(phi(xEnd + 1, j) - phi(xEnd, j));    phi(xEnd + 3, j) =        phi(xEnd + 2, j) +        phi(xEnd + 2, j) /            sqrt(phi(xEnd + 2, j) * phi(xEnd + 2, j) + m_xH * m_xH) *            fabs(phi(xEnd + 2, j) - phi(xEnd + 1, j));  }  // bottom  for (int i = xBegin; i != xEnd; i++) {    phi(i, 3) = phi(i, 4) + phi(i, 4) /                                sqrt(phi(i, 4) * phi(i, 4) + m_yH * m_yH) *                                fabs(phi(i, 4) - phi(i, 5));    phi(i, 2) = phi(i, 3) + phi(i, 3) /                                sqrt(phi(i, 3) * phi(i, 3) + m_yH * m_yH) *                                fabs(phi(i, 3) - phi(i, 4));    phi(i, 1) = phi(i, 2) + phi(i, 2) /                                sqrt(phi(i, 2) * phi(i, 2) + m_yH * m_yH) *                                fabs(phi(i, 2) - phi(i, 3));    phi(i, 0) = phi(i, 1) + phi(i, 1) /                                sqrt(phi(i, 1) * phi(i, 1) + m_yH * m_yH) *                                fabs(phi(i, 1) - phi(i, 2));  }  // top  for (int i = xBegin; i != xEnd; i++) {    phi(i, yEnd) = phi(i, yEnd - 1) +                   phi(i, yEnd - 1) /                       sqrt(phi(i, yEnd - 1) * phi(i, yEnd - 1) + m_yH * m_yH) *                       fabs(phi(i, yEnd - 1) - phi(i, yEnd - 2));    phi(i, yEnd + 1) =        phi(i, yEnd) + phi(i, yEnd) /                           sqrt(phi(i, yEnd) * phi(i, yEnd) + m_yH * m_yH) *                           fabs(phi(i, yEnd) - phi(i, yEnd - 1));    phi(i, yEnd + 2) =        phi(i, yEnd + 1) +        phi(i, yEnd + 1) /            sqrt(phi(i, yEnd + 1) * phi(i, yEnd + 1) + m_yH * m_yH) *            fabs(phi(i, yEnd + 1) - phi(i, yEnd));    phi(i, yEnd + 3) =        phi(i, yEnd + 2) +        phi(i, yEnd + 2) /            sqrt(phi(i, yEnd + 2) * phi(i, yEnd + 2) + m_yH * m_yH) *            fabs(phi(i, yEnd + 2) - phi(i, yEnd + 1));  }}double Clevel_set_method::phi_weno_5th(double v1, double v2, double v3,                                       double v4, double v5) {  //定义光滑因子  double IS1 = 0.0, IS2 = 0.0, IS3 = 0.0;  IS1 = 13.0 / 12 * pow(v1 - 2.0 * v2 + v3, 2) +        1.0 / 4 * pow(v1 - 4.0 * v2 + 3.0 * v3, 2);  IS2 = 13.0 / 12 * pow(v2 - 2.0 * v3 + v4, 2) + 1.0 / 4 * pow(v2 - v4, 2);  IS3 = 13.0 / 12 * pow(v3 - 2.0 * v4 + v5, 2) +        1.0 / 4 * pow(3.0 * v3 - 4.0 * v4 + v5, 2);  //定义线性权  double a1 = 1.0 / 10.0 / pow(Weno_Eps + IS1, 2);  double a2 = 6.0 / 10.0 / pow(Weno_Eps + IS2, 2);  double a3 = 3.0 / 10.0 / pow(Weno_Eps + IS3, 2);  //定义非线性权  double omega1 = a1 / (a1 + a2 + a3);  double omega2 = a2 / (a1 + a2 + a3);  double omega3 = a3 / (a1 + a2 + a3);  //加权求和  double phi_x = omega1 * (v1 / 3.0 - 7.0 * v2 / 6.0 + 11.0 * v3 / 6.0) +                 omega2 * (-v2 / 6.0 + 5.0 * v3 / 6.0 + v4 / 3.0) +                 omega3 * (v3 / 3.0 + 5.0 * v4 / 6.0 - v5 / 6.0);  return phi_x;}void Clevel_set_method::X_Weno_plus(int i, int j) {  double v1, v2, v3, v4, v5;  v1 = (phi(i + 3, j) - phi(i + 2, j)) / m_xH;  v2 = (phi(i + 2, j) - phi(i + 1, j)) / m_xH;  v3 = (phi(i + 1, j) - phi(i, j)) / m_xH;  v4 = (phi(i, j) - phi(i - 1, j)) / m_xH;  v5 = (phi(i - 1, j) - phi(i - 2, j)) / m_xH;  X_partial_phi(i, j) = phi_weno_5th(v1, v2, v3, v4, v5);}void Clevel_set_method::X_Weno_mins(int i, int j) {  double v1, v2, v3, v4, v5;  v5 = (phi(i + 2, j) - phi(i + 1, j)) / m_xH;  v4 = (phi(i + 1, j) - phi(i, j)) / m_xH;  v3 = (phi(i, j) - phi(i - 1, j)) / m_xH;  v2 = (phi(i - 1, j) - phi(i - 2, j)) / m_xH;  v1 = (phi(i - 2, j) - phi(i - 3, j)) / m_xH;  X_partial_phi(i, j) = phi_weno_5th(v1, v2, v3, v4, v5);}void Clevel_set_method::Y_Weno_plus(int i, int j) {  double v1, v2, v3, v4, v5;  v1 = (phi(i, j + 3) - phi(i, j + 2)) / m_yH;  v2 = (phi(i, j + 2) - phi(i, j + 1)) / m_yH;  v3 = (phi(i, j + 1) - phi(i, j)) / m_yH;  v4 = (phi(i, j) - phi(i, j - 1)) / m_yH;  v5 = (phi(i, j - 1) - phi(i, j - 2)) / m_yH;  Y_partial_phi(i, j) = phi_weno_5th(v1, v2, v3, v4, v5);}void Clevel_set_method::Y_Weno_mins(int i, int j) {  double v1, v2, v3, v4, v5;  v5 = (phi(i, j + 2) - phi(i, j + 1)) / m_yH;  v4 = (phi(i, j + 1) - phi(i, j)) / m_yH;  v3 = (phi(i, j) - phi(i, j - 1)) / m_yH;  v2 = (phi(i, j - 1) - phi(i, j - 2)) / m_yH;  v1 = (phi(i, j - 2) - phi(i, j - 3)) / m_yH;  Y_partial_phi(i, j) = phi_weno_5th(v1, v2, v3, v4, v5);}double Clevel_set_method::pre_reinitialization(int i, int j) {  double a, b, c, d, s, g;  a = (phi(i, j) - phi(i - 1, j)) / m_xH;  b = (phi(i + 1, j) - phi(i, j)) / m_xH;  c = (phi(i, j) - phi(i, j - 1)) / m_yH;  d = (phi(i, j + 1) - phi(i, j)) / m_yH;  // begin  s = phi(i, j) / sqrt(phi(i, j) * phi(i, j) + m_xH * m_xH);  g = max(s, 0.0) * (sqrt(max(pow(max(a, 0.0), 2), pow(min(b, 0.0), 2)) +                          max(pow(max(c, 0.0), 2), pow(min(d, 0.0), 2))) -                     1.0) +      min(s, 0.0) * (sqrt(max(pow(min(a, 0.0), 2), pow(max(b, 0.0), 2)) +                          max(pow(min(c, 0.0), 2), pow(max(d, 0.0), 2))) -                     1.0);  return g;  /*  if (phi(i,j)<0)  {      g=sqrt(max(pow(min(a,0.0),2),pow(max(b,0.0),2))+max(pow(min(c,0.0),2),pow(max(d,0.0),2)))-1.0;  }  else if (phi(i,j)>0)  {      g=sqrt(max(pow(max(a,0.0),2),pow(min(b,0.0),2))+max(pow(max(c,0.0),2),pow(min(d,0.0),2)))-1.0;  }  else  {      g=0.0;  }  return g; */}void Clevel_set_method::reinitialization() {  double E = 0.0;  do {    E = 0.0;    CMatrix<double> phi_temp;    phi_temp.Resize(xTotal, yTotal);    phi_temp = phi;    level_set_SetBoundary();    for (int i = xBegin; i != xEnd; i++) {      for (int j = yBegin; j != yEnd; j++) {        phi_temp(i, j) = phi(i, j) - m_time_step * pre_reinitialization(i, j);        E += fabs(phi(i, j) - phi_temp(i, j));      }    }    phi = phi_temp;    E /= ((xEnd - xBegin) * (yEnd - yBegin));  } while (E > (m_time_step / m_xH / m_yH));}// void Clevel_set_method::level_set_Output() {//     int i,j;//     ofstream out_final("result.plt", ios::out);//     out_final.setf(ios::fixed | ios::showpoint);//     out_final <<//     "(Variables=\"x\",\"y\",\"phi_zero\",\"x_velocity\",\"y_velocity\" )"<<//     endl; out_final << "Zone I=" << m_xNum << "  j=" << m_yNum << "  f=point"//     << endl; for (i = xBegin; i != xEnd; i++)//     {//         for (j = yBegin; j != yEnd; j++)//         {//             if (phi(i,j)>0)phi(i,j)=1.0;//             else phi(i,j)=-1.0;//             out_final << Grid(i, j).x << " " << Grid(i, j).y << " " <<//             phi(i,j) << " "<< velocity(i,j).x <<  " " << velocity(i,j).y<<" "//             << endl;//         }//     }//     out_final.close();// }void Clevel_set_method::SpatSolver() {  level_set_SetBoundary();  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      if (velocity(i, j).x < 0) {        X_Weno_plus(i, j);      } else if (velocity(i, j).x > 0) {        X_Weno_mins(i, j);      } else {        X_partial_phi(i, j) = 0.0;      }      if (velocity(i, j).y < 0) {        Y_Weno_plus(i, j);      } else if (velocity(i, j).y > 0) {        Y_Weno_mins(i, j);      } else {        Y_partial_phi(i, j) = 0.0;      }    }  }  // CMatrix<double> phi_temp;  // phi_temp.Resize(xTotal,yTotal);  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      phi_temp(i, j) =          phi(i, j) - m_time_step * (velocity(i, j).x * X_partial_phi(i, j) +                                     velocity(i, j).y * Y_partial_phi(i, j));    }  }  phi = phi_temp;}CMatrix<double>& Clevel_set_method::X_dericition_delta_phi() {  level_set_SetBoundary();  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      if (velocity(i, j).x < 0) {        X_Weno_plus(i, j);      } else if (velocity(i, j).x > 0) {        X_Weno_mins(i, j);      } else {        X_partial_phi(i, j) = 0.0;      }      if (velocity(i, j).y < 0) {        Y_Weno_plus(i, j);      } else if (velocity(i, j).y > 0) {        Y_Weno_mins(i, j);      } else {        Y_partial_phi(i, j) = 0.0;      }    }  }  return (X_partial_phi);}CMatrix<double>& Clevel_set_method::Y_dericition_delta_phi() {  level_set_SetBoundary();  for (int i = xBegin; i != xEnd; i++) {    for (int j = yBegin; j != yEnd; j++) {      if (velocity(i, j).x < 0) {        X_Weno_plus(i, j);      } else if (velocity(i, j).x > 0) {        X_Weno_mins(i, j);      } else {        X_partial_phi(i, j) = 0.0;      }      if (velocity(i, j).y < 0) {        Y_Weno_plus(i, j);      } else if (velocity(i, j).y > 0) {        Y_Weno_mins(i, j);      } else {        Y_partial_phi(i, j) = 0.0;      }    }  }  return (Y_partial_phi);}void Clevel_set_method::TempSolver(int timepre) {  double t = 0.0;  assert(timepre >= 1 && timepre <= 3);  switch (timepre) {  case 1:    while (t < m_Time) {      t += m_time_step;      // out << "time: " << t << endl;      SpatSolver();      reinitialization();    }    break;  case 2:    while (t < m_Time) {      t += m_time_step;      // cout << "time: " << t << endl;      // CMatrix<double> phi_temp;      // phi_temp.Resize(xTotal,yTotal);      phi_temp = phi;      SpatSolver();      SpatSolver();      reinitialization();      phi = 0.5 * (phi + phi_temp);    }  case 3:    while (t < m_Time) {      t += m_time_step;      // cout << "time: " << t << endl;      // CMatrix<double> phi_temp;      // phi_temp.Resize(xTotal,yTotal);      phi_temp = phi;      SpatSolver();      SpatSolver();      phi = 3.0 / 4 * phi_temp + 1.0 / 4 * phi;      SpatSolver();      phi = 1.0 / 3 * phi_temp + 2.0 / 3 * phi;      reinitialization();    }  }}CMatrix<double> Clevel_set_method::level_set_Output() { return(phi); }